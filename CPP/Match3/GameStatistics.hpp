#pragma once

#include <vector>
#include <numeric>
#include <algorithm>
#include <type_traits>
#include <functional>

namespace GameLauncher {

    /// <summary>
    /// ????????? ??????? ??? ?????????? ?????????? ?? ????????? ????????
    /// ???????????: T ?????? ???????????? ???????? < ? ???? ?????????????? ?????
    /// </summary>
    template<typename T>
    typename std::enable_if<std::is_arithmetic<T>::value, struct Statistics>::type
        CalculateStatistics(const std::vector<T>& data) {
        struct Statistics {
            T min;
            T max;
            double average;
            T median;
            T sum;
        };

        if (data.empty()) {
            return Statistics{ T(), T(), 0.0, T(), T() };
        }

        // ??????? ????? ??? ??????????
        std::vector<T> sorted = data;
        std::sort(sorted.begin(), sorted.end());

        // ????????? ??????????
        Statistics stats;
        stats.min = sorted.front();
        stats.max = sorted.back();
        stats.sum = std::accumulate(sorted.begin(), sorted.end(), T(0));
        stats.average = static_cast<double>(stats.sum) / sorted.size();

        // ????????? ???????
        size_t size = sorted.size();
        if (size % 2 == 0) {
            stats.median = (sorted[size / 2 - 1] + sorted[size / 2]) / 2;
        }
        else {
            stats.median = sorted[size / 2];
        }

        return stats;
    }

    /// <summary>
    /// ????????? ??????? ??? ?????????? ? ????????????? ?????????
    /// </summary>
    template<typename InputT, typename OutputT, typename FilterFunc, typename TransformFunc>
    std::vector<OutputT> FilterAndTransform(
        const std::vector<InputT>& input,
        FilterFunc filter,
        TransformFunc transform) {

        std::vector<OutputT> result;
        result.reserve(input.size());

        for (const auto& item : input) {
            if (filter(item)) {
                result.push_back(transform(item));
            }
        }

        return result;
    }

    /// <summary>
    /// ??????? ??? ?????????? ???????? ????? ?? ????????? ??????????
    /// </summary>
    double CalculateAverageScore(const std::vector<std::shared_ptr<BaseGameManager>>& managers) {
        if (managers.empty()) return 0.0;

        // ?????????? std::accumulate ??? ????????????
        double total = 0.0;
        int count = 0;

        for (const auto& manager : managers) {
            // ??????????? ? ExtendedGameManager ???? ????????
            if (auto extended = std::dynamic_pointer_cast<ExtendedGameManager>(manager)) {
                auto scoreManager = extended->GetScoreManager();
                if (scoreManager) {
                    total += scoreManager->GetCurrentScore();
                    count++;
                }
            }
        }

        return count > 0 ? total / count : 0.0;
    }
}